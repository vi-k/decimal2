# Decimals

The test is awaiting translation into English.

Это ещё один пакет для Decimals - десятичных дробей с фиксированной запятой.

## Почему?

По состоянию на январь 2025 на pub.dev есть несколько пакетов, работающих
с Decimals:

### [decimal](https://pub.dev/packages/decimal)

Замечательный пакет, корректно работающий с Decimals. Существует с 2014 года и
постоянно обновляется. В одном из последних обновлений (3.2.0) была значительно
увеличена производительность. До этого скорость была слабой стороной этого
пакета. Именно это стало одной из причин, почему появился
[decimal2](https://pub.dev/packages/decimal2), т.к.
[decimal2](https://pub.dev/packages/decimal2) создавался до появления
[decimal 3.2.0](https://pub.dev/packages/decimal).

### [fixed](https://pub.dev/packages/fixed)

Пакет для работы с числами с фиксированной запятой. Это почти тоже самое, что
и Decimals, но не совсем. Вам не удастся просто так выполнить операцию 1 / 8
и получить ожидаемые 0.125:

```dart
final a = Fixed.fromInt(100, scale: 2); // 1.00
final b = Fixed.fromInt(800, scale: 2); // 8.00
print('$a / $b = ${a / b}'); // 0.13
```

Результатом будет 0.13, а не 0.125. Причина именно в том, что понимается в этом
пакете под фиксированном количеством знаков после запятой. Как в обоих
операндах, результат также будет иметь 2 знака после запятой. Т.е. фиксация
количества знаков после запятой, по мнению автора пакета, относится к тому, что
результат деления сохраняет кол-во знаков после запятой делимоого или делителя.
Для получения корректного значения необходимо, чтобы хотя бы один из операндов
имел scale равным 3:

```dart
final a = Fixed.fromInt(100, scale: 2); // 1.00
final b = Fixed.fromInt(8000, scale: 3); // 8.000
print('$a / $b = ${a / b}'); // 1.00 / 8.000 = 0.125
```

Или:

```dart
final a = Fixed.fromInt(100, scale: 2); // 1.00
final b = Fixed.fromInt(800, scale: 2); // 8.00
final scaledA = a.copyWith(scale: 3);
print('$scaledA / $b = ${scaledA / b}'); // 1.000 / 8.00 = 0.125
```

Но главный недостаток пакета в том, что для операции деления под капотом
испольуется `double`:

```dart
final v = Fixed.parse('111111111111111111');
print(v * v); // 12345679012345678987654320987654321
print(v * v / v); // 111111111111111120
```

Это очень неожиданно! Обычно числа с фиксированной запятой используют
для того, чтобы избежать погрешностей операций с плавающей запятой. А не
наоборот.

Из-за этого, к сожалению, я не могу рекомендовать этот пакет никому. На мой
взгляд, это слишком серьёзная ошибка, чтобы ей пренебречь.

Но порадовало то, что автор поддерживает пакет и быстро исправляет найденные
ошибки. Может, поправит и это?

### [decimal_type](https://pub.dev/packages/decimal_type)

Так как меня не устраивала производительность пакета
[decimal](https://pub.dev/packages/decimal), этот пакет привлёк моё внимание
своей скоростью. К сожалению, он как и [fixed](https://pub.dev/packages/fixed),
использует для деления `double`.

```dart
var a = Decimal(BigInt.parse('644385861467633436300000'), decimalPrecision: 0);
var b = Decimal.fromInt(123);
print('$a / $b = ${a / b}'); // FormatException: Could not parse BigInt 238909442826288e+21
```

Числа делятся в `double`, частное преобразуется в строку, а строка в `BigInt`.
Но `double.toStringAsFixed` не всегда возвращает результат в виде "fixed". Когда
наступает предел погрешности, он переключается на `toStringAsExponential`. Автор
не учёл это. Впрочем, это хорошо, т.к. сразу понятно, что пользоваться этим
пакетом нельзя.

### [big_decimal](https://pub.dev/packages/big_decimal)

Ещё один пакет с очень хорошей производительностью. Похоже, перенесён с Java:

> A bugless implementation of BigDecimal in Dart based on Java's BigDecimal.

Но в нём не просто разделить 1 на 2 (в [fixed](https://pub.dev/packages/fixed)
эта проблема начиналась чуть позже: с деления на 8):

```dart
final a = BigDecimal.one;
final b = BigDecimal.two;
print('$a / $b = ${a.divide(b)}'); //  Exception: Rounding necessary
```

Т.е. по умолчанию числа можно разделить, только указав режим округления. Но
если мне нужно получить полный результат без округления, а в случае с 1 / 2 это
возможно, то нужно самостоятельно увеличить scale:

```dart
final a = BigDecimal.one;
final scaledA = a.withScale(1);
final b = BigDecimal.two;
print('$scaledA / $b = ${scaledA.divide(b)}');
```

Что делать в случае, когда scale частного заранее не известен, не ясно.

### Как должно быть

Чтобы было понятно, и в [decimal](https://pub.dev/packages/decimal), и
и в [decimal2](https://pub.dev/packages/decimal2) подобных трудностей нет.

Только [decimal](https://pub.dev/packages/decimal) не торопится возвращать
результат в виде Decimal, т.к. не всякий результат деления может быть
представлен десятичной дробью:

```dart
final a = Decimal.one;
final b = Decimal.fromInt(256);
print('$a / $b = ${a / b}'); // 1 / 256 = 1/256
```

Результат вернётся в виде `Rational` (пакет
[rational](https://pub.dev/packages/rational), похоже, того же автора), т.е.
в виде дроби. Но его можно легко перевести в `Decimal`:

```dart
final a = Decimal.one;
final b = Decimal.fromInt(256);
print('$a / $b = ${(a / b).toDecimal()}'); // 1 / 256 = 0.00390625
```

Если же частное нельзя представить в виде десятичного числа, т.е. число имеет
бесконечное количество знаков после запятой (имеет бесконечную точность), то
либо обработать ошибку (поймать исключение), либо передать в `toDecimal`
значение `scaleOnInfinitePrecision` для ограничения точности.

[decimal2](https://pub.dev/packages/decimal2) сразу вернёт результат:

```dart
final a = Decimal.one;
final b = Decimal(256);
print('$a / $b = ${a / b}'); // 1 / 256 = 0.00390625
```

Я решил, что если вы делите десятичные дроби и хотите получить в ответе
такую же десятичную дробь, то знаете, что делаете, и поэтому промежуточные
действия вам не нужны. Если результат нельзя получить в виде десятичной дроби,
будет брошено исключение. А вот его уже можно будет преобразовать в нужный
результат:

```dart
final a = d2.Decimal.one;
final b = d2.Decimal(3);
try {
  print('$a / $b = ${a / b}');
} on d2.DecimalDivideException catch (e) {
  print('${e.dividend} / ${e.divisor} = ${e.fraction}'); // 1 / 3 = 1/3
  print('${e.dividend} / ${e.divisor} = ${e.division}'); // 1 / 3 = 0 remainder 1
  print('${e.dividend} / ${e.divisor} = ${e.round(6)}'); // 1 / 3 = 0.333333
}
```

Поход, реализованный в [decimal](https://pub.dev/packages/decimal), удобен тем,
что позволяет совершить ряд действий, промежуточные результаты которых не будут
являться Decimal, но конечным итогом ожидается Decimal. Например: 1 / 3 * 9:

```dart
final r1 = Decimal.fromInt(1) / Decimal.fromInt(3);
final r2 = r1 * Decimal.fromInt(9).toRational();
final r3 = r2.toDecimal(); // 3
```

Пакет, работающий только с десятичными дробыми, не сможет так изящно решить
такой пример. Либо придётся прибегать к округлению и потерять точность:

```
1 / 3 = 0.333
0.333 * 9 = 2.997
```

Либо использовать дополнительные решения для работы с дробями, например пакет
[fraction](https://pub.dev/packages/fraction), или тот же
[rational](https://pub.dev/packages/rational).

Но я посчитал, что в пакете, рассчитанном на работу с десятичными числами
приоритетом должны быть именно они. Результат деления в виде `double` можно
получить с помощью `divideToDouble`, дробь можно получить с помощью
`divideToFraction()`, а целое частное с остатком с помощью
`divideWithRemainder`.

## Измерения производительности

 Тесты проводились на Apple M2 Pro 32 Gb. Код тестов написан с помощью
 пакета [benchmark_harness](https://pub.dev/packages/benchmark_harness).
 Каждый тест проводился не менее 2 сек, в течение которых выполнялось
 упражнение тестс до достижения времени окончания. В одном упражнении 100
 циклов выполнения операции. Одна операция совершает ряд однотипных действий
 с несколькими значениями. В таблице вы видете средняя время выполнения одной
 операции в микросекундах. Звездочками отмечены лучшие результаты и близкие к
 ним (до 5% расхождения).

|                       |     decimal | decimal_type |     fixed | big_decimal | decimal2-decimal |
|:----------------------|------------:|-------------:|----------:|------------:|-----------------:|
| add                   |  ★ 1.825 µs |     3.344 µs |  2.405 µs |    2.252 µs |       ★ 1.691 µs |
| multiply-large        |  ★ 0.137 µs |   ★ 0.132 µs |  0.176 µs |  ★ 0.130 µs |       ★ 0.134 µs |
| multiply-small        |  ★ 0.139 µs |   ★ 0.132 µs |    ERROR¹ |  ★ 0.131 µs |       ★ 0.131 µs |
| divide-large          |    7.690 µs |       ERROR² |    ERROR³ |   1.644 µs⁴ |       ★ 2.013 µs |
| divide-small          |  501.365 µs |       ERROR¹ |    ERROR¹ |      ERROR⁵ |      ★ 13.075 µs |
| divide-large-and-view |    7.781 µs |       ERROR² |    ERROR³ |   1.685 µs⁴ |       ★ 2.017 µs |
| divide-small-and-view |  498.637 µs |       ERROR¹ |    ERROR¹ |      ERROR⁵ |      ★ 14.151 µs |
| raw-view              |   20.798 µs |    25.472 µs | 58.094 µs | ★ 17.784 µs |      ★ 16.561 µs |
| raw-view-zeros        |   81.682 µs |    72.415 µs | 70.514 µs | ★ 16.133 µs |      ★ 15.123 µs |
| prepared-view         | ★ 16.014 µs |    24.989 µs | 58.369 µs | ★ 17.425 µs |      ★ 16.556 µs |
| prepared-view-zeros   |  ★ 1.560 µs |    72.258 µs | 70.501 µs |   15.681 µs |       ★ 1.611 µs |

¹ The results don't match.

² FormatException: Could not parse BigInt\n662462759719942e+72.

³ The amount must be less than 10^20.

⁴ Результаты не отмечены как лучшие, т.к. пакет не выполняет полноценные
  операции деления, за счёт чего и получает прирост производительности.

⁵ Exception: Rounding necessary.

Описание тестов:

- add. Сложение чисел:

  10000000000000000000 + 1000000000000000000 + 100000000000000000 + 10000000000000000 + 1000000000000000 + 100000000000000 + 10000000000000 + 1000000000000 + 100000000000 + 10000000000 + 1000000000 + 100000000 + 10000000 + 1000000 + 100000 + 10000 + 1000 + 100 + 10 + 1 + 0.1 + 0.01 + 0.001 + 0.0001 + 0.00001 + 0.000001 + 0.0000001 + 0.00000001 + 0.000000001 + 0.0000000001 + 0.00000000001 + 0.000000000001 + 0.0000000000001 + 0.00000000000001 + 0.000000000000001 + 0.0000000000000001 + 0.00000000000000001 + 0.000000000000000001 + 0.0000000000000000001 + 0.00000000000000000001 = 11111111111111111111.11111111111111111111

- multiply-large. Умножение больших чисел:

  123456789 * 123456789 * 123456789 * 123456789 * 123456789 * 123456789 * 123456789 * 123456789 * 123456789 * 123456789 = 822526259147102579504761143661535547764137892295514168093701699676416207799736601

- multiply-small. Умножение малых чисел:

  0.0123456789 * 0.0123456789 * 0.0123456789 * 0.0123456789 * 0.0123456789 * 0.0123456789 * 0.0123456789 * 0.0123456789 * 0.0123456789 * 0.0123456789 = 0.0000000000000000000822526259147102579504761143661535547764137892295514168093701699676416207799736601

- divide-large. Деление больших чисел:

  822526259147102579504761143661535547764137892295514168093701699676416207799736601 / 123456789 / 123456789 / 123456789 / 123456789 / 123456789 / 123456789 / 123456789 / 123456789 / 123456789 / 123456789 = 1

- divide-small. Деление малых чисел:

  1 / 256 / 256 / 256 / 256 / 256 / 256 / 256 / 256 / 256 = 0.000000000000000000000211758236813575084767080625169910490512847900390625

- divide-large-and-view. Деление больших чисел и преобразование результата
  в читабельный формат

  Пакеты могут использовать в своей работе промежуточные результаты, ускоряющие
  скорость выполнения операций, но не имеющие вид десятичной дроби, понятный
  пользователю. Поэтому тест divide-large, где осуществляется только деление,
  может быть далёк от реальной жизни. Этот тест выполняет ту же операцию, что
  и divide-large, но дополнительно преобразует результат операции (только
  операции, а не каждой шага в этой операции) в читабельный вид с целью
  сравнения результатов.

- divide-small-and-view. Деление малых чисел и преобразование результата
  в читабельный формат

  Пакеты могут использовать в своей работе промежуточные результаты, ускоряющие
  скорость выполнения операций, но не имеющие вид десятичной дроби, понятный
  пользователю. Поэтому тест divide-small, где осуществляется только деление,
  может быть далёк от реальной жизни. Этот тест выполняет ту же операцию, что
  и divide-small, но дополнительно преобразует результат операции (только
  операции, а не каждой шага в этой операции) в читабельный вид с целью
  сравнения результатов.

- raw-view. Преобразование только что созданных чисел в читабельный формат:

  - 123456789012345678901234567890123456789
  - 1234567890123456789012345678901234567.89
  - 12345678901234567890123456789012345.6789
  - 123456789012345678901234567890123.456789
  - 1234567890123456789012345678901.23456789
  - 12345678901234567890123456789.0123456789
  - 123456789012345678901234567.890123456789
  - 1234567890123456789012345.67890123456789
  - 12345678901234567890123.4567890123456789
  - 123456789012345678901.234567890123456789
  - 1234567890123456789.01234567890123456789
  - 12345678901234567.8901234567890123456789
  - 123456789012345.678901234567890123456789
  - 1234567890123.45678901234567890123456789
  - 12345678901.2345678901234567890123456789
  - 123456789.012345678901234567890123456789
  - 1234567.89012345678901234567890123456789
  - 12345.6789012345678901234567890123456789
  - 123.456789012345678901234567890123456789
  - 1.23456789012345678901234567890123456789

  Обычно это ресурсоёмкая задача, т.к. пакет не успевает сделать какие-либо
  оптимизации с числом.

- raw-view-zeros. Преобразование только что созданных чисел с большим
  количеством начальных или конечных нулей в читабельный формат:

  - 100000000000000000000000000000000000000
  - 10000000000000000000000000000000000
  - 1000000000000000000000000000000
  - 100000000000000000000000000
  - 10000000000000000000000
  - 1000000000000000000
  - 100000000000000
  - 10000000000
  - 1000000
  - 100
  - 0.01
  - 0.000001
  - 0.0000000001
  - 0.00000000000001
  - 0.000000000000000001
  - 0.0000000000000000000001
  - 0.00000000000000000000000001
  - 0.000000000000000000000000000001
  - 0.0000000000000000000000000000000001
  - 0.00000000000000000000000000000000000001

  Преобразование таких чисел обычно значительно отличается от преобразования
  чисел без нулей, как в raw-view. Каждый из тестов отдельно может дать
  неверное представление о производительности, поэтому их надо рассматривать
  вместе.

- prepared-view. Преобразование подготовленных чисел (если пакет это
  поддерживает) в читабельный формат

  Пакеты могут использовать в своей работе механизмы оптимизации (например,
  сохранения ранее вычисленных значений). Тест raw-view не позволяет оценить
  плоды этой оптимизации. Этот же тест даёт такую возможность, выполняя ту же
  операцию, что и raw-view. Сравните результаты обоих тестов.

  Пакеты [decimal_type](https://pub.dev/packages/decimal_type),
  [fixed](https://pub.dev/packages/fixed),
  [big_decimal](https://pub.dev/packages/big_decimal) обходятся без
  оптимизации.

- prepared-view-zeros. Преобразование подготовленных чисел (если пакет это
  поддерживает) с большим количеством начальных или конечных нулей
  в читабельный формат

  Преобразование таких чисел обычно значительно отличается от преобразования
  чисел без нулей, как в prepared-view. Каждый из тестов отдельно может дать
  неверное представление о производительности, поэтому их надо рассматривать
  вместе.

  Пакеты могут использовать в своей работе механизмы оптимизации (например,
  сохранения ранее вычисленных значений). Тест raw-view-zeros не позволяет
  оценить плоды этой оптимизации. Этот же тест даёт такую возможность,
  выполняя ту же операцию, что и raw-view-zeros. Сравните результаты обоих
  тестов.

  Пакеты [decimal_type](https://pub.dev/packages/decimal_type),
  [fixed](https://pub.dev/packages/fixed),
  [big_decimal](https://pub.dev/packages/big_decimal) обходятся без
  оптимизации.

В начале января 2025 года колонка с пакетом
[decimal](https://pub.dev/packages/decimal) выглядела совершенно иначе.
Значения были на два порядка выше. Примерно как сейчас в тесте divide-small.
Можно только порадоваться за автора пакета и пользователей таким улучшениям.

## Сравнение [decimal](https://pub.dev/packages/decimal) ## и [decimal2](https://pub.dev/packages/decimal2)

Меньше всего мне хочется конкурировать с автором
[decimal](https://pub.dev/packages/decimal), особенно когда вижу, как долго
этот пакет существует. Не думаю, что я могу преложить что-то откровенно новое
в обычном подходе к Decimal. Даже используя под капотом разные подходы,
конечный результат будет снаружи, а не внутри. А это практически одинаковый
набор функций с практически одинаковой производительностью.

Но на самом деле на решение написать свой
[decimal2](https://pub.dev/packages/decimal2) повлияла не только плохая (на тот
момент) производительность [decimal](https://pub.dev/packages/decimal). Была
ещё одна причина. Для моей задачи мне нужен был легковесный Decimal, которому
под капотом для хранения значений достаточно было обычного `int` вместо
`BigInt`. Мои значения умещались даже в int32. Это результаты тренировок:
геопозиция, дистанция, набор высоты, темп, пульс, каденс, мощность. Мне, как
программисту старого поколения, морально тяжело расходовать ресурсы там, где
в этом нет необходимости. Тем более я ожидаю большого объёма и данных
и расчётов с ними. И я удивился, не обнаружив на pub.dev готового решения.

Итак, `Decimal` изначально не был основной целью пакета. Главным был
`ShortDecimal`. `Decimal` стал просто естественным продолжением.

## ShortDecimal

### ShortDecimal vs Decimal

Все те же функции, что и в `Decimal`, но значения хранятся в `int` со всеми
вытекающими отсюда последствиями. С одной стороны, это скорость работы, а
с другой стороны это возможность неконтролируемого переполнения значения,
которого не будет в случае использования `BigInt`. Можно написать код, который
будет контролировать переполнение, но это значительно усложнит и замедлит
алгоритмы. Операция суммирования слишком простая, чтобы её обкладывать
дополнительными проверками. Каждая такая проверка будет увеличивать время
выполнения операции в разы.

Единственное, что особенного делает `ShortDecimal`, так это постоянная
оптимизация получаемого значения, чтобы дольше сохранять возможность не
выходить за границы `int`. Например, умножение двух чисел: 1.2 * 5. Под капотом
всё хранится в целочисленной переменной (`int` или `BigInt`) и в параметре,
указывающем, где находится запятая (обычно называемом `scale`). Скорее всего
в начале работы 1.2 будет храниться как (12, 1), а 5 как (5, 0).

Умножение таких чисел достаточно простая операция: основы умножаются, а scale
складываются. Результат будет: (60, 1). Это и есть 6.0. Но ведь мы могли бы
сохранить этот результат как (6, 0)? Верно! В конечном итоге для пользователя
это будет одним и тем же значением. Что происходит под капотом у класса,
сохраняется вдали от глаз пользователя. (Мне, кстати, не совсем понятно, когда
реализации Decimal выставляют scale и подобные вещи наружу. Зачем пользователю
знать, как реально хранится его число, как (6, 0) или как (6000, 3), если для
него это одно и тоде число?)

Можно, конечно, после каждой операции приводить значение в норму, т.е.
к (6, 0), но это дополнительное время, которое в большинстве случаев тратить
излишне. И там, где используется `BigInt`, в этом нет практической надобности:
нет слишком большой разницы между (6,0) и (60000000000, 10). А вот в случае
с тиспользованием `int` мы можем очень быстро дойти до переполнения. Например,
достаточно всего 18 раз умножить 1.0 на 1.0, т.е. (10, 1) на (10, 1), чтобы
выйти за границы `int`. И поэтому, чтобы дольше находиться в границах `int`,
делать упаковку значения после каждой операции. Но в случае с `int` это будет
всё равно гораздо быстрее, чем `BigInt` без упаковки значений.

### Оптимизация

Когда нужно вернуть пользователю свойства числа, понятные человеческому
восприятию, например, количество значащих цифр после запятой, то без упаковки
числа не обойтись. А уже имея "упакованное" число, можно некоторые операции,
например, преобразование числа в строку, делать существенно быстрее. В этой
упаковке числа и состоит оптимизация, за счёт которой некоторые тесты
выполняются гораздо быстрее (работа с уже упакованным числом), а некоторые,
наоборот, гораздо медленнее, когда на упаковку тратится неоправданно много
времени.

В `Decimal` я попытался найти баланс: упаковывать число только там, где это
необходимо, а в других местах использовать его, если оно есть, и обходиться без
него, если его нет. При этом вынес наружу метод `optimize`, который позволит
вручную упаковать число для оптимизации производительности там, когда алгоритм
этого не делает. Этот метод можно вызывать безопасно много раз. В реальности
он упаковывает значение только один раз.

Метод явно относится к реализации, а не к бизнес-логике. Мне не очень нравится
его наличие, но я не нашёл лучшего решения, т.к. не смог за пользователя
решить, в каком случае лучше использовать упаковку числа, а в каком её лучше
избежать. Единственное, чем я попытался ограничить отрицательные последствия
наличия этого метода, так это его названием. Это не `pack`, это не `rescale`.
Это `optimize`.

В следующем примере оптимизация значительно ускоряет преобразование числа
в строку:


```dart
final v = Decimal(1000000000000000000, shiftRight: 18);

final sw = Stopwatch()..start();
for (var i = 0; i < 10000000; i++) {
  v.toString();
}
sw.stop();
print(sw.elapsed); // 0:00:02.406469

sw
  ..reset()
  ..start();
for (var i = 0; i < 10000000; i++) {
  // Это оптимизация, так как мы много раз используем одно и тоже значение.
  // В реальности оптимизация выполнится только один раз. Остальное время мы
  // вхолостую будем запускать метод. Я специально поместил его внутрь цикла,
  // чтобы показать, что многократное его использование на одном и том же числе
  // не принесёт значительного вреда.
  v.optimize();
  v.toString();
}
sw.stop();
print(sw.elapsed); // 00:00:00.061205
```

Но если нам будут поступать каждый раз новые числа, и мы будем вместе с каждым
преобразованием в строку заниматься "оптимизацией", то только потеряем
в производительности. В то время как отсутствие неоправданной "оптимизации"
сохранит ресурсы. Именно поэтому я не сделал её обязательной внутри `toString`.

```dart
var v = Decimal(1000000000000000000, shiftRight: 18);

final sw = Stopwatch()..start();
for (var i = 0; i < 10000000; i++) {
  // Имитируем ситуацию поступления новых чисел, создавая копию числа. Пакеты
  // не предоставляют отдельного метода для создания копий, поэтому используем
  // лайфхак с двойным отрицанием. Отрицание гарантированно (если только это
  // не ноль) создаст нам копию. Второе отрицание вернёт знак.
  v = -(-v);
  v.toString();
}
sw.stop();
print(sw.elapsed); // 0:00:02.523939

sw
  ..reset()
  ..start();
for (var i = 0; i < 10000000; i++) {
  v = -(-v);
  // Если нам нужно только один раз вывести числа и больше мы нигде их
  // не будем использовать, то такая "оптимизация" окажется излишней.
  // Оптимизация всё равно останется оптимизацией, но мы заплатим за неё
  // слишком дорого.
  v.optimize();
  v.toString(); // 0:00:15.592658
}
sw.stop();
print(sw.elapsed);
```
